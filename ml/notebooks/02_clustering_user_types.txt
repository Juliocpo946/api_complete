{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Clustering de Tipos de Usuario\n",
    "## Modelo funcional con datos simulados"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.append('../scripts')\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.metrics import silhouette_score, silhouette_samples, davies_bouldin_score\n",
    "\n",
    "import joblib\n",
    "import json\n",
    "\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Cargar Datos Preprocesados"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('../output/features_for_clustering.csv')\n",
    "\n",
    "print(f\"Datos cargados: {df.shape[0]} usuarios, {df.shape[1]-1} features\")\n",
    "print(f\"\\nFeatures disponibles:\")\n",
    "print(df.columns.tolist())\n",
    "\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Preparación de Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "feature_cols = [col for col in df.columns if col != 'user_id']\n",
    "X = df[feature_cols].values\n",
    "user_ids = df['user_id'].values\n",
    "\n",
    "scaler = StandardScaler()\n",
    "X_scaled = scaler.fit_transform(X)\n",
    "\n",
    "print(f\"Features normalizadas: {X_scaled.shape}\")\n",
    "print(f\"\\nMedia después de normalización: {X_scaled.mean(axis=0).round(3)}\")\n",
    "print(f\"Desviación estándar después de normalización: {X_scaled.std(axis=0).round(3)}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Determinar Número Óptimo de Clusters (Método del Codo)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "inertias = []\n",
    "silhouette_scores = []\n",
    "K_range = range(2, 9)\n",
    "\n",
    "for k in K_range:\n",
    "    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)\n",
    "    kmeans.fit(X_scaled)\n",
    "    inertias.append(kmeans.inertia_)\n",
    "    silhouette_scores.append(silhouette_score(X_scaled, kmeans.labels_))\n",
    "\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))\n",
    "\n",
    "ax1.plot(K_range, inertias, 'bo-', linewidth=2, markersize=8)\n",
    "ax1.set_xlabel('Número de Clusters (K)', fontsize=12)\n",
    "ax1.set_ylabel('Inercia (SSE)', fontsize=12)\n",
    "ax1.set_title('Método del Codo', fontsize=14)\n",
    "ax1.grid(True, alpha=0.3)\n",
    "\n",
    "ax2.plot(K_range, silhouette_scores, 'ro-', linewidth=2, markersize=8)\n",
    "ax2.set_xlabel('Número de Clusters (K)', fontsize=12)\n",
    "ax2.set_ylabel('Silhouette Score', fontsize=12)\n",
    "ax2.set_title('Silhouette Score por K', fontsize=14)\n",
    "ax2.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('../output/elbow_silhouette.png', dpi=300, bbox_inches='tight')\n",
    "plt.show()\n",
    "\n",
    "print(\"\\nMétricas por número de clusters:\")\n",
    "metrics_df = pd.DataFrame({\n",
    "    'K': list(K_range),\n",
    "    'Inercia': inertias,\n",
    "    'Silhouette': silhouette_scores\n",
    "})\n",
    "print(metrics_df)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Entrenar Modelo con K Óptimo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "optimal_k = 4\n",
    "\n",
    "kmeans_final = KMeans(n_clusters=optimal_k, random_state=42, n_init=20)\n",
    "cluster_labels = kmeans_final.fit_predict(X_scaled)\n",
    "\n",
    "df['cluster'] = cluster_labels\n",
    "\n",
    "silhouette_avg = silhouette_score(X_scaled, cluster_labels)\n",
    "davies_bouldin = davies_bouldin_score(X_scaled, cluster_labels)\n",
    "\n",
    "print(f\"Modelo entrenado con K={optimal_k}\")\n",
    "print(f\"\\nMétricas del modelo:\")\n",
    "print(f\"  - Silhouette Score: {silhouette_avg:.3f}\")\n",
    "print(f\"  - Davies-Bouldin Index: {davies_bouldin:.3f} (menor es mejor)\")\n",
    "print(f\"  - Inercia: {kmeans_final.inertia_:.2f}\")\n",
    "\n",
    "print(f\"\\nDistribución de usuarios por cluster:\")\n",
    "cluster_counts = pd.Series(cluster_labels).value_counts().sort_index()\n",
    "for cluster_id, count in cluster_counts.items():\n",
    "    percentage = (count / len(cluster_labels)) * 100\n",
    "    print(f\"  Cluster {cluster_id}: {count} usuarios ({percentage:.1f}%)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Análisis de Centroides"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "centroids_scaled = kmeans_final.cluster_centers_\n",
    "centroids_original = scaler.inverse_transform(centroids_scaled)\n",
    "\n",
    "centroids_df = pd.DataFrame(centroids_original, columns=feature_cols)\n",
    "centroids_df.index = [f'Cluster {i}' for i in range(optimal_k)]\n",
    "\n",
    "print(\"Centroides de los clusters (valores originales):\")\n",
    "print(centroids_df.round(3))\n",
    "\n",
    "plt.figure(figsize=(14, 8))\n",
    "sns.heatmap(centroids_df.T, annot=True, fmt='.2f', cmap='RdYlGn', \n",
    "            center=centroids_df.values.mean(), cbar_kws={'label': 'Valor'})\n",
    "plt.title('Heatmap de Centroides por Cluster', fontsize=14, pad=20)\n",
    "plt.xlabel('Cluster', fontsize=12)\n",
    "plt.ylabel('Feature', fontsize=12)\n",
    "plt.tight_layout()\n",
    "plt.savefig('../output/centroids_heatmap.png', dpi=300, bbox_inches='tight')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Interpretación y Etiquetado de Clusters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cluster_stats = df.groupby('cluster')[feature_cols].mean()\n",
    "\n",
    "cluster_labels_map = {}\n",
    "\n",
    "for cluster_id in range(optimal_k):\n",
    "    stats = cluster_stats.loc[cluster_id]\n",
    "    \n",
    "    if stats['completion_rate'] > 0.7 and stats['avg_frustration'] < 0.45:\n",
    "        label = \"Rápido Visual\"\n",
    "        description = \"Alta tasa de completitud, baja frustración, buena atención visual\"\n",
    "    elif stats['avg_frustration'] > 0.55 and stats['completion_rate'] > 0.55:\n",
    "        label = \"Lector Constante\"\n",
    "        description = \"Tolera frustración, completa actividades, pausas estratégicas\"\n",
    "    elif stats['distraction_events_per_hour'] > 6 and stats['completion_rate'] < 0.55:\n",
    "        label = \"Disperso Visual\"\n",
    "        description = \"Alta distracción, abandona actividades complejas, muchas pausas\"\n",
    "    else:\n",
    "        label = \"Fatigado Visual\"\n",
    "        description = \"Fatiga visual, pausas frecuentes, mejor en sesiones cortas\"\n",
    "    \n",
    "    cluster_labels_map[cluster_id] = {\n",
    "        'name': label,\n",
    "        'description': description\n",
    "    }\n",
    "\n",
    "print(\"\\nETIQUETAS DE CLUSTERS:\")\n",
    "print(\"=\"*60)\n",
    "for cluster_id, info in cluster_labels_map.items():\n",
    "    count = (cluster_labels == cluster_id).sum()\n",
    "    percentage = (count / len(cluster_labels)) * 100\n",
    "    print(f\"\\nCluster {cluster_id}: {info['name']}\")\n",
    "    print(f\"  Usuarios: {count} ({percentage:.1f}%)\")\n",
    "    print(f\"  Descripción: {info['description']}\")\n",
    "    print(f\"  Características clave:\")\n",
    "    print(f\"    - Completion rate: {cluster_stats.loc[cluster_id, 'completion_rate']:.2%}\")\n",
    "    print(f\"    - Frustración promedio: {cluster_stats.loc[cluster_id, 'avg_frustration']:.3f}\")\n",
    "    print(f\"    - Atención visual: {cluster_stats.loc[cluster_id, 'avg_visual_attention']:.1f}%\")\n",
    "    print(f\"    - Distracciones/hora: {cluster_stats.loc[cluster_id, 'distraction_events_per_hour']:.2f}\")\n",
    "    print(f\"    - Pausas promedio: {cluster_stats.loc[cluster_id, 'avg_pause_count']:.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Visualización con PCA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pca = PCA(n_components=2, random_state=42)\n",
    "X_pca = pca.fit_transform(X_scaled)\n",
    "\n",
    "print(f\"Varianza explicada por componentes PCA:\")\n",
    "print(f\"  PC1: {pca.explained_variance_ratio_[0]:.2%}\")\n",
    "print(f\"  PC2: {pca.explained_variance_ratio_[1]:.2%}\")\n",
    "print(f\"  Total: {pca.explained_variance_ratio_.sum():.2%}\")\n",
    "\n",
    "plt.figure(figsize=(12, 8))\n",
    "colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A']\n",
    "\n",
    "for cluster_id in range(optimal_k):\n",
    "    mask = cluster_labels == cluster_id\n",
    "    plt.scatter(X_pca[mask, 0], X_pca[mask, 1], \n",
    "                c=colors[cluster_id], label=cluster_labels_map[cluster_id]['name'],\n",
    "                alpha=0.6, s=100, edgecolors='black', linewidth=0.5)\n",
    "\n",
    "centroids_pca = pca.transform(centroids_scaled)\n",
    "plt.scatter(centroids_pca[:, 0], centroids_pca[:, 1], \n",
    "            c='black', marker='X', s=300, edgecolors='yellow', linewidth=2,\n",
    "            label='Centroides', zorder=5)\n",
    "\n",
    "plt.xlabel(f'PC1 ({pca.explained_variance_ratio_[0]:.1%} varianza)', fontsize=12)\n",
    "plt.ylabel(f'PC2 ({pca.explained_variance_ratio_[1]:.1%} varianza)', fontsize=12)\n",
    "plt.title('Visualización de Clusters (PCA 2D)', fontsize=14, pad=20)\n",
    "plt.legend(loc='best', fontsize=10)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.savefig('../output/clusters_pca_visualization.png', dpi=300, bbox_inches='tight')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. Silhouette Plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "silhouette_vals = silhouette_samples(X_scaled, cluster_labels)\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(10, 8))\n",
    "y_lower = 10\n",
    "\n",
    "for i in range(optimal_k):\n",
    "    cluster_silhouette_vals = silhouette_vals[cluster_labels == i]\n",
    "    cluster_silhouette_vals.sort()\n",
    "    \n",
    "    size_cluster_i = cluster_silhouette_vals.shape[0]\n",
    "    y_upper = y_lower + size_cluster_i\n",
    "    \n",
    "    ax.fill_betweenx(np.arange(y_lower, y_upper),\n",
    "                      0, cluster_silhouette_vals,\n",
    "                      alpha=0.7, color=colors[i],\n",
    "                      label=cluster_labels_map[i]['name'])\n",
    "    \n",
    "    ax.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i), fontsize=12, fontweight='bold')\n",
    "    \n",
    "    y_lower = y_upper + 10\n",
    "\n",
    "ax.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\", linewidth=2,\n",
    "           label=f'Silhouette promedio: {silhouette_avg:.3f}')\n",
    "ax.set_xlabel(\"Silhouette Coefficient\", fontsize=12)\n",
    "ax.set_ylabel(\"Cluster\", fontsize=12)\n",
    "ax.set_title(\"Silhouette Plot por Cluster\", fontsize=14, pad=20)\n",
    "ax.legend(loc='best')\n",
    "plt.tight_layout()\n",
    "plt.savefig('../output/silhouette_plot.png', dpi=300, bbox_inches='tight')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. Comparación de Clusters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "comparison_features = [\n",
    "    'completion_rate',\n",
    "    'avg_frustration',\n",
    "    'avg_visual_attention',\n",
    "    'distraction_events_per_hour',\n",
    "    'avg_pause_count'\n",
    "]\n",
    "\n",
    "fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for idx, feature in enumerate(comparison_features):\n",
    "    data_by_cluster = [df[df['cluster'] == i][feature].values for i in range(optimal_k)]\n",
    "    \n",
    "    bp = axes[idx].boxplot(data_by_cluster, labels=[cluster_labels_map[i]['name'] for i in range(optimal_k)],\n",
    "                            patch_artist=True)\n",
    "    \n",
    "    for patch, color in zip(bp['boxes'], colors):\n",
    "        patch.set_facecolor(color)\n",
    "        patch.set_alpha(0.7)\n",
    "    \n",
    "    axes[idx].set_title(feature, fontsize=11, fontweight='bold')\n",
    "    axes[idx].set_ylabel('Valor', fontsize=10)\n",
    "    axes[idx].tick_params(axis='x', rotation=45)\n",
    "    axes[idx].grid(True, alpha=0.3)\n",
    "\n",
    "fig.delaxes(axes[5])\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('../output/clusters_comparison.png', dpi=300, bbox_inches='tight')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 10. Guardar Modelo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "joblib.dump(kmeans_final, '../models/user_type_classifier.pkl')\n",
    "joblib.dump(scaler, '../models/scaler.pkl')\n",
    "\n",
    "labels_export = {str(k): v['name'] for k, v in cluster_labels_map.items()}\n",
    "with open('../models/cluster_labels.json', 'w') as f:\n",
    "    json.dump(labels_export, f, indent=2)\n",
    "\n",
    "model_metadata = {\n",
    "    'n_clusters': optimal_k,\n",
    "    'features': feature_cols,\n",
    "    'silhouette_score': float(silhouette_avg),\n",
    "    'davies_bouldin_score': float(davies_bouldin),\n",
    "    'inertia': float(kmeans_final.inertia_),\n",
    "    'cluster_distribution': {str(k): int(v) for k, v in cluster_counts.items()},\n",
    "    'trained_on': pd.Timestamp.now().isoformat()\n",
    "}\n",
    "\n",
    "with open('../models/model_metadata.json', 'w') as f:\n",
    "    json.dump(model_metadata, f, indent=2)\n",
    "\n",
    "df.to_csv('../output/users_with_clusters.csv', index=False)\n",
    "\n",
    "print(\"Modelo guardado exitosamente:\")\n",
    "print(\"  - models/user_type_classifier.pkl\")\n",
    "print(\"  - models/scaler.pkl\")\n",
    "print(\"  - models/cluster_labels.json\")\n",
    "print(\"  - models/model_metadata.json\")\n",
    "print(\"  - output/users_with_clusters.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 11. Prueba de Predicción"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "test_user = df.iloc[0][feature_cols].values.reshape(1, -1)\n",
    "test_user_scaled = scaler.transform(test_user)\n",
    "predicted_cluster = kmeans_final.predict(test_user_scaled)[0]\n",
    "\n",
    "print(f\"Usuario de prueba (user_id: {df.iloc[0]['user_id']}):\")\n",
    "print(f\"\\nFeatures:\")\n",
    "for feat, val in zip(feature_cols, test_user[0]):\n",
    "    print(f\"  {feat}: {val:.3f}\")\n",
    "\n",
    "print(f\"\\nPredicción:\")\n",
    "print(f\"  Cluster ID: {predicted_cluster}\")\n",
    "print(f\"  Cluster Name: {cluster_labels_map[predicted_cluster]['name']}\")\n",
    "print(f\"  Descripción: {cluster_labels_map[predicted_cluster]['description']}\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
